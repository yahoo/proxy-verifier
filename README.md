<!---
The following toc was autogenerated from the shell using:
https://github.com/ekalinin/github-markdown-toc

cd ~/bin
wget https://raw.githubusercontent.com/ekalinin/github-markdown-toc/master/gh-md-toc
chmod 755 gh-md-toc
cd <path/to/proxy-verifier/repo>
gh-md-toc README.md

Then copy and paste the output here.
-->


Table of Contents
=================

   * [Table of Contents](#table-of-contents)
   * [Proxy Verifier](#proxy-verifier)
      * [Traffic Replay Specification](#traffic-replay-specification)
         * [HTTP Specification](#http-specification)
            * [Server Response Lookup](#server-response-lookup)
         * [Protocol Specification](#protocol-specification)
         * [Session and Transaction Delay Specification](#session-and-transaction-delay-specification)
      * [Traffic Verification Specification](#traffic-verification-specification)
         * [Field Verification](#field-verification)
         * [URL Verification](#url-verification)
         * [Status Verification](#status-verification)
         * [Example Replay File](#example-replay-file)
      * [Install](#install)
         * [Prerequisites](#prerequisites)
         * [Building](#building)
         * [Running the Tests](#running-the-tests)
            * [Unit Tests](#unit-tests)
            * [Gold Tests](#gold-tests)
      * [Usage](#usage)
         * [Required Arguments](#required-arguments)
         * [Optional Arguments](#optional-arguments)
            * [--format &lt;format-specification&gt;](#--format-format-specification)
            * [--keys &lt;key1 key2 ... keyn&gt;](#--keys-key1-key2--keyn)
            * [--verbose](#--verbose)
            * [--no-proxy](#--no-proxy)
            * [--strict](#--strict)
            * [--rate &lt;requests/second&gt;](#--rate-requestssecond)
            * [--repeat &lt;number&gt;](#--repeat-number)
      * [Contribute](#contribute)
      * [License](#license)

# Proxy Verifier

Proxy Verifier is an HTTP replay tool designed to verify the behavior of HTTP
proxies. It builds a verifier-client binary and a verifier-server binary which
each read a set of YAML files (or JSON files, since JSON is YAML) that specify
the HTTP traffic for the two to exchange.

Proxy Verifier supports the HTTP replay of the following protocols:

* HTTP/1.x and HTTP/2
* HTTP and HTTP over TLS
* IPv4 and IPv6

Broadly speaking, Proxy Verifier is designed to address two proxy testing
needs:

* **Traffic correctness testing**: In this context Proxy Verifier can be used
  in manual or automated end to end tests to verify correct behavior of the
  details of generally a small number of transactions. [Transaction
  Box](https://github.com/SolidWallOfCode/txn_box) is an example of a tool that
  relies entirely on Proxy Verifier for its automated end to end tests (see its
  [autest](https://github.com/SolidWallOfCode/txn_box/tree/master/test/autest)
  directory).
* **Production simulation testing**: In this context, Proxy Verifier is used in
  an isolated lab environment configured as much like a production environment
  as possible. The Verifier client and server are provided replay files as
  input that are either auto generated or collected via a tool like [Traffic
  Dump](https://docs.trafficserver.apache.org/en/latest/admin-guide/plugins/traffic_dump.en.html)
  from an actual production environment. Proxy verifier then replays this
  production-like traffic against the proxy under test. Proxy Verifier can
  replay such traffic at rates over 10k requests per second. Here are some
  examples where this use of Proxy Verifier can be helpful:

  * Safely testing experimental versions of a patch.
  * Running diagnostic versions of the proxy that may not be performant enough
    for the production environment. Debug, Valgrind, and ASan builds are
    examples of build configurations whose resultant proxy performance may be
    impossible to run in production but can be run safely in the production
    simulation via Proxy Verifier.
  * Performance comparison across versions of the proxy. Since Proxy Verifier
    replays the traffic for the same set of replay files consistently across
    runs, different versions of the proxy can be compared with regard to their
    performance against the same replay dataset. This affords the ability to
    compare detect performance improvement or degradation across versions of the
    proxy.

It should be noted that when using Proxy Verifier in a production simulation
environment, the proxy will be receiving traffic from the client that looks
like production traffic. Thus, by design, the HTTP request targets and Host
header fields will reference actual production servers. It will be important to
configure the proxy under test to direct these requests not to the actual
production servers but to the Proxy Verifier server or servers.  The way this
is achieved will depend upon the proxy. One way to accomplish this is to
configure the production environment with a test DNS server such as
[MicroDNS](https://bitbucket.org/autestsuite/microdns/src/master/) configured
to resolve all host names to the Proxy Verifier server or servers in the
production simulation environment.

## Traffic Replay Specification

### HTTP Specification

Proxy Verifier traffic behavior is specified via YAML files. The behavior for
each connection is specified under the top-most `sessions` node, the value of
which is a sequence where each item in the sequence describes the
characteristics of each connection. For each session the protocol stack can be
specified via the `protocol` node. This node describes the protocol
characteristics of the connection such as what version of HTTP to use, whether
to use TLS and what the characteristics of the TLS handshake should be.  In
the absence of a `protocol` node the default protocol is HTTP/1 over TCP.
See [Protocol Specification](#protocol-specification) below for details about the
`protocol` node.  Each session is run in parallel by the verifier-client. 

In addition to protocol specification, each session in the `sessions`
sequence contains a `transactions` node. This itself is a sequence of
transactions that should be replayed for the associated session. Within each
transaction, Proxy Verifier's traffic replay behavior is specified in the
`client-request` and `server-response` nodes. `client-request` nodes are used
by the Proxy Verifier client and tell it what kind of HTTP requests it should
generate. `server-response` nodes are used by the Proxy Verifier server to
indicate what HTTP responses it should generate. Proxy traffic verification
behavior is described in the `proxy-request` and `proxy-response` nodes which
will be covered in [Traffic Verification
Specification](#traffic-verification-specification). For HTTP/1, these
transactions are run in sequence for each session; for HTTP/2, the transactions
are run in parallel.

For HTTP/1 requests, `client-request` has a map as a value which contains each of
the following key/value YAML nodes:

1. `method`: This takes the HTTP method as the value, such as `GET` or `POST`.
1. `url`: This takes the request target as the value, such as `/a/path.asp` or
   `https://www.example.com/a/path.asp`.
1. `version`: This takes the HTTP version, such as `1.1` or `2`.
1. `headers`: This takes a `fields` node which has, as a value, a sequence of
   HTTP fields. Each field is itself a sequence of two values: the name of the
   field and the value for the field.
1. `content`: This specifies the number of bytes to send. It takes a map as a
   value. This map will contain an item with `size` as its name which maps to
   an integer describing how many bytes the body should be. An auto-generated
   body of this many bytes will be sent to the client.

Here's an example of a `client-request` node describing an HTTP/1.1 POST
request with a request target of `/pictures/flower.jpeg`
and containing four header fields with a body size of 399 bytes:

```YAML
  client-request:
    method: POST
    url: /pictures/flower.jpeg
    version: '1.1'
    headers:
      fields:
      - [ Host, www.example.com ]
      - [ Content-Type, image/jpeg ]
      - [ Content-Length, '399' ]
      - [ uuid, 1234 ]
    content:
        size: 399
```

For convenience, if Proxy Verifier detects a Content-Length header, then the
`content` node stating the size of the body is not required. Thus this can be
simplified to:

```YAML
  client-request:
    method: POST
    url: /pictures/flower.jpeg
    version: '1.1'
    headers:
      fields:
      - [ Host, www.example.com ]
      - [ Content-Type, image/jpeg ]
      - [ Content-Length, '399' ]
      - [ uuid, 1234 ]
```

For HTTP/2, the protocol describes the initial request line values with pseudo
header fields. For that protocol, therefore, the user need not specify the
`method`, `url`, and `version` nodes and would instead specify these values
more naturally as pseudo headers in the `fields` sequence. Here is an example of
an HTTP/2 `client-request` analogous to the HTTP/1 request above (note that the
`Content-Length` header field is optional in HTTP/2 and as such is omitted here):

```YAML
  client-request:
    headers:
      fields:
      - [ :method, POST ]
      - [ :scheme, https ]
      - [ :authority, www.example.com ]
      - [ :path, /pictures/flower.jpeg ]
      - [ Content-Type, image/jpeg ]
      - [ uuid, 1234 ]
    content:
      size: 399
```

`server-response` nodes indicate how the Proxy Verifier server should respond
to HTTP requests. In place of `method`, `url`, and `version`, HTTP/1 responses
take the following nodes:

1. `status`: This takes an integer corresponding to the HTTP response status,
   such as `200` or `404`.
1. `reason`: This takes a string that describes the status, such as `"OK"` or
   `"Not Found"`.

Here's an example of an HTTP/1 `server-response` with a status of 200, four
fields, and a body of size 3,432 bytes:

```YAML
  server-response:
    status: 200
    reason: OK
    headers:
      fields:
      - [ Date, "Sat, 16 Mar 2019 03:11:36 GMT" ]
      - [ Content-Type, image/jpeg ]
      - [ Transfer-Encoding, chunked ]
      - [ Connection, keep-alive ]
    content:
      size: 3432
```

Observe in this case that the response contains the `Transfer-Encoding:
chunked` header field, indicating that the body should be chunk encoded. Proxy
Verifier supports chunk encoding for both requests and responses and will use
this when it detects the `Transfer-Encoding: chunked` header field. In this
case, the 3,432 bytes will be the size of the chunked body payload without the
bytes for the chunk protocol (chunk headers, etc.).

For HTTP/2, the status code is described in the `:status` pseudo header field.
Also, HTTP/2 does not allow for chunk encoding nor does it use the `Connection`
header field, using instead its framing mechanism to describe the body and
session lifetime. An analogous HTTP/2 response to the HTTP/1 request above,
therefore, would look like the following:

```YAML
  server-response:
    headers:
      fields:
      - [ :status, 200 ]
      - [ Date, "Sat, 16 Mar 2019 03:11:36 GMT" ]
      - [ Content-Type, image/jpeg ]
    content:
      size: 3432
```

#### Server Response Lookup

The `client-request` and `server-response` nodes are all that is required to
direct Proxy Verifier's replay of a transaction. The next section will describe
how to specify proxy transaction verification behavior via the `proxy-request` and
`proxy-response` nodes. Before proceeding to that, however, it is valuable to
understand how the Verifier server decides which response to send for any given
request it receives.  Consider again the `client-request` node in the preceding
example:

```YAML
  client-request:
    headers:
      fields:
      - [ :method, POST ]
      - [ :scheme, https ]
      - [ :authority, www.example.com ]
      - [ :path, /pictures/flower.jpeg ]
      - [ Content-Type, image/jpeg ]
      - [ Content-Length, '399' ]
      - [ uuid, 1234 ]
    content:
      size: 399
```

Note the presence of the `uuid` field. A field such as this is sent by the
client and used by the server. When a server receives a request, keep in mind
that all it has to direct its behavior is what it has parsed from the replay
file or files and what it sees in the request. There may be hundreds of
thousands of parsed `server-response` nodes, each describing a unique response
with which the server may reply for any given incoming request. The server does
not talk directly to the client, so it cannot communicate with it and say, "Hey
Verifier client, I just read such and such request off the wire. Which response
would you like me to send for this?" When it receives an HTTP request,
therefore, it only has the contents of that request from which to choose its
response. To facilitate the server's behavior, a unique *key* is associated
with every request. During the YAML parsing phase, the Verifier server
associates each parsed `server-response` with a key it derives from the
associated `client-request` for the transaction. During the traffic replay
phase, when it reads a request off the wire, it derives a key from the HTTP
request using the same process for generating keys from `client-request` nodes
used in the parsing phase. It then looks up the proper YAML-specified response
using that key. By default, Proxy Verifier uses the `uuid` HTTP header field
values as the key, as utilized in the examples in this document, but this is
configurable via the `--format` command line argument. For details see the
section describing this argument below.

Both the client and the server will fail the YAML parsing phase and exit with a
non-zero return if either parses a transaction for which they cannot derive a
key.  If during the traffic processing phase the Verifier server somehow
receives a request for which it cannot derive a key, it will return a *404 Not
Found* response and close the connection upon which it received the request.

### Protocol Specification

The above discussed the replay YAML nodes that describe how Proxy Verifier will
craft HTTP layer traffic. This section discusses how the user specifies the
lower layer protocols used to transport this HTTP traffic.

As stated above, each HTTP session is described as an item under the `sessions`
node sequence. Each session takes a map. HTTP transactions are described under
the `transactions` key described above. In addition to `transactions`, a
session also takes an optional `protocol` node. This node takes an ordered
sequence of maps, where each item in the sequence describes the characteristics
of a protocol layer.  The sequence is expected to be ordered from higher layer
protocols (such as HTTP and TLS) to lower layer protocols (such as IP).

Here is an example protocol node along with `sessions` and `transactions`
nodes provided to give some context:

```YAML
sessions:

- protocol:
  - name: http
    version: 2
  - name: tls
    sni: test_sni
  - name: tcp
  - name: ip

  transactions:
  # ...
```

Note again how the `protocol` node is under the `sessions` node which takes a
sequence of sessions. This sample shows the start of a single session that, in
this case, provides a protocol description via a `protocol` key. This same
session also has a truncated set of transactions that will be specified under
the `transactions` key. Looking further at the `protocol` node, observe that
this session has four layers described for it: http, tls, tcp, and ip. The
`http` node specifies that the session should use the HTTP/2 protocol. The
`tls` node specifies that the client should use an SNI of "test\_sni" in the
TLS client hello handshake. Further, this should be transported over TCP on IP.

The following nodes are supported for `protocol`:

| Name   | Node                         | Supported Values    | Description
| -----  |--------                      | ----------------    | -----------
| http   |                              |                     |
|        | version                      | {1, 2}              | Whether to use HTTP/1 or HTTP/2.
| tls    |                              |                     |
|        | sni                          | string              | The SNI to send in the TLS handshake.
|        | request-certificate          | boolean             | Whether the client or server should request a certificate from the proxy.
|        | proxy-provided-certificate   | boolean             | This directs the same behavior as the request-certificate directive. This alias is helpful when the node describes what happened in the past, such as in the context of a replay file specified by [Traffic Dump](https://docs.trafficserver.apache.org/en/latest/admin-guide/plugins/traffic_dump.en.html).
|        | verify-mode                  | {0-15}              | The value to pass directly to OpenSSL's `SSL_set_verify` to control peer verification in the TLS handshake. This allows fine grained control over TLS verification behavior.  `0` corresponds with SSL_VERIFY_NONE, `1` corresponds with SSL_VERIFY_PEER, `2` corresponds with SSL_VERIFY_FAIL_IF_NO_PEER_CERT, `4` corresponds with SSL_VERIFY_CLIENT_ONCE, and `8` corresponds with SSL_VERIFY_POST_HANDSHAKE. Any bitwise OR'd value of these values can be provided. For details about their behavior, see OpenSSL's [SSL_verify_cb](https://www.openssl.org/docs/man1.1.1/man3/SSL_verify_cb.html) documentation.
|        | alpn-protocols               | sequence of strings | This specifies the server's protocol list used in ALPN selection. See OpenSSL's [SSL_select_next_proto](https://www.openssl.org/docs/man1.0.2/man3/SSL_select_next_proto.html) documentation for details.
| tcp    |                              |                     |
| ip     |                              |                     |


The following protocol specification features are not currently implemented:

* HTTP/2 is only supported over TLS. Proxy Verifier uses ALPN in the TLS
  handshake to negotiate HTTP/2 with the proxy.  HTTP/2 upgrade from HTTP/1
  without TLS is not supported.
* The user cannot supply a TLS version to negotiate for the handshake.
  Currently, if the TLS node is present, Proxy Verifier will use the highest
  TLS version it can negotiate with the peer. This is OpenSSL's default
  behavior. An enhancement request to support A TLS version specification
  feature request is recorded in issue
  [101](https://github.com/yahoo/proxy-verifier/issues/101).
* Similarly, the user cannot specify whether to use IPv4 or IPv6 via an
  `ip:version` node.  Proxy Verifier can test IPv6, but it does so via the user
  passing IPv6 addresses on the commandline. An IP version feature request is
  recorded in issue [100](https://github.com/yahoo/proxy-verifier/issues/100).
* Only TCP is supported. There have been recent discussions about adding
  HTTP/3 support, which is over UDP, but work for that has not yet started.

If there is no `protocol` node specified, then Proxy Verifier will default to
establishing an HTTP/1 connection over TCP (no TLS).

### Session and Transaction Delay Specification

A user can also stipulate per `session` and/or per `client-request` delays to
be inserted by the Verifier client during the replay of traffic. This is done
via the `delay` node which takes a unit-specified duration for the associated
delay.  During traffic replay, the delay is inserted before the associated
session is established or before the client request is sent.  Proxy Verifier
recognizes the following time duration units for the `delay` node:

Unit Suffix | Meaning
----------- | -------
s           | seconds
ms          | milliseconds
us          | microseconds

Here is a sample replay file snippet that specifies a 2 second delay before
establishing the first session and a 15 millisecond delay before sending the
first client request in that session.

```YAML
sessions:
- delay: 2s

  transactions:

    client-request:
      delay: 15ms

      method: POST
      url: /a/path.jpeg
      version: '1.1'
      headers:
        fields:
        - [ Content-Length, '399' ]
        - [ Content-Type, image/jpeg ]
        - [ Host, example.com ]
        - [ uuid, 1 ]
```

Be aware of the following characteristics of the `delay` node:

* `delay` is currently only interpreted and used by the Verifier client in
`client-request` nodes. A server delay is not currently specifiable. Please
file a ticket if server-side delay specification would be helpful.
* Notice that Proxy Verifier supports microsecond level delay granularity, and
does indeed faithfully insert delays at the appropriate times during replay
with that precision of time. Be aware, however, that for the vast majority of
networks anything more precise than a millisecond will not generally be useful.

See also [--rate &lt;requests/second&gt;](#--rate-requestssecond) below for
rate specification of transactions.

## Traffic Verification Specification

In addition to replaying HTTP traffic as described above, Proxy Verifier also
implements proxy traffic verification. For any given transaction, Proxy
Verifier can optionally verify characteristics of an HTTP request line (for
HTTP/1 requests - HTTP/2 requests do not have a request line), the response
status, and the content of HTTP fields for requests and responses.  Proxy
Verifier also supports field verification of HTTP/2 pseudo header fields.
Whereas `client-request` and `server-response` nodes direct the Verifier client
and server (respectively) on how to send traffic, `proxy-request` and
`proxy-response` nodes direct the server and client (respectively) on how to
verify the traffic it receives from the proxy. Thus:

* `client-request` nodes are used by the Verifier client to direct how it will
  generate requests it will send to the proxy.
* `server-response` nodes are used by the Verifier server to direct how it will
  generate responses to send to the proxy.
* `proxy-request` nodes are used by the Verifier server to direct how it will
  verify requests received from the proxy.
* `proxy-response` nodes are used by the Verifier client to direct how it will
  verify responses received from the proxy.

In the event that the proxy does not produce the stipulated traffic according
to a verification directive, the Proxy Verifier client or server that detects
the violation will emit a log indicating the violation and will, upon process
exit, return a non-zero status to the shell.

Traffic verification is an optional feature. Thus if Proxy Verifier is being
used simply to replay traffic and the verification features are not helpful,
then the user can simply omit the `proxy-request` and `proxy-response` nodes
and no verification will be performed.

The following sections describe how to specify traffic verification in the YAML
replay file.

### Field Verification

Recall that in `client-request` and `server-response` nodes, fields are
specified via a sequence of two items: the field name followed by the field
value. For instance, the following incomplete `client-request` node contains
the specification of a single `Content-Length` field (it is incomplete because
it does not specify the method, request target, etc., but this snippet
sufficiently demonstrates a typical description of an HTTP field):

```YAML
  client-request:
    headers:
      fields:
      - [ Content-Length, 399 ]
```

For this client request, Proxy Verifier is directed to create a `Content-Length`
HTTP field with a value of `399`.

Field verification is specified in a similar manner, but the second item in the
sequence is a map describing how the field should be verified. The map takes a
`value` item describing the characteristics of the value to verify, if
applicable, and an `as` item providing a directive describing how the field
should be verified.  Here is an example of a `proxy-request` node directing the
Verifier server to verify the characteristics of the `Content-Length` field
received from the proxy:

```YAML
  proxy-request:
    headers:
      fields:
      - [ Content-Length, { value: 399, as: equal } ]
```

Observe the following from this verification example:

* As described above, notice that the second entry in the field specification
  is a map instead of a scalar field value. The Proxy Verifier parser
  recognizes this map type as providing a verification specification.
* As with `client-request` and `server-response` field specifications, the
  first item in the list describes the field name, in this case
  "Content-Length". This indicates that this verification rule applies to the
  "Content-Length" HTTP field from the proxy.
* The directive is specified via the `as` key. In this example, `equal` is the
  directive for this particular field verification, indicating that the
  Verifier server should verify that the proxy's request for this transaction
  contains a `Content-Length` field with the exact value of `399`.

Proxy Verifier supports six field verification directives:

Directive  | Description
---------  | ------------
absent     |  The *absence* of a field with the specified field name.
present    |  The *presence* of a field with the specified field name and having any or no value.
equal      |  The presence of a field with the specified field name and a value *equal* to the specified value.
contains   |  The presence of a field with the specified name with a value *containing* the specified value.
prefix     |  The presence of a field with the specified name with a value *prefixed* with the specified value.
suffix     |  The presence of a field with the specified name with a value *suffixed* with the specified value.

For all of these field verification behaviors, field names are matched case
insensitively while field values are matched case sensitively.

Thus the following field specification requests no field verification because it does not include a directive and the second item in the sequence is a scarlar:

```YAML
  - [ X-Forwarded-For, 10.10.10.2 ]
```

Such non-operative fields can also be specified using the map syntax without an
`as` item:

```YAML
  - [ X-Forwarded-For, { value: 10.10.10.2 } ]
```

Fields like this in `proxy-request` and `proxy-response` nodes are permissible
by Proxy Verifier's parser even though they have no functional impact (i.e.,
they do not direct Proxy Verifier's traffic behavior because they are not in
`client-request` nor `server-response` nodes, and they do not describe any
verification behavior). Allowing such fields affords the user the ability to
record the proxy's traffic behavior in situations where field verification is
not required or desired.  For example, the [Traffic
Dump](https://docs.trafficserver.apache.org/en/latest/admin-guide/plugins/traffic_dump.en.html)
Traffic Server plugin records HTTP traffic and uses these proxy HTTP fields to
indicate what fields were sent by the Traffic Server proxy to the client and
the server. This can be helpful for analyzing the proxy's behavior via these
replay files. Thus this proxy traffic recording function can be helpful to the
user even though Proxy Verifier treats the fields as non-operable.


The following demonstrates the `absent` directive which specifies that the HTTP field `X-Forwarded-For` _with any value_ should not have been sent by the proxy:

```YAML
  - [ X-Forwarded-For, { as: absent } ]
```

The following demonstrates the `present` directive which specifies that the HTTP field `X-Forwarded-For` _with any value_ should have been sent by the proxy:

```YAML
  - [ X-Forwarded-For, { as: present } ]
```

Notice that for both the `absent` and the `present` directives, the `value` map item is not relevant and need not be provided and, in fact, will be ignored by Proxy Verifier if it is provided.

The following demonstrates the `equal` directive which specifies that `X-Forwarded-For` should have been received from the proxy with the exact value "10.10.10.2":

```YAML
  - [ X-Forwarded-For, { value: 10.10.10.2, as: equal } ]
```

The following demonstrates the `contains` directive which specifies that `X-Forwarded-For` should have been received from the proxy containing the value "10" at any position in the field value:

```YAML
  - [ X-Forwarded-For, { value: 10, as: contains } ]
```

The following demonstrates the `prefix` directive which specifies that `X-Forwarded-For` should have been received from the proxy with a field value starting with "1":

```YAML
  - [ X-Forwarded-For, { value: 1, as: prefix } ]
```

The following demonstrates the `suffix` directive which specifies that `X-Forwarded-For` should have been received from the proxy with a field value ending with "2":

```YAML
  - [ X-Forwarded-For, { value: 2, as: suffix } ]
```

### URL Verification

In a manner similar to field verification described above, a mechanism exists
to verify the parts of URLs in the request line being received from the proxy
by the server. This mechanism is useful for verifying the request targets of
HTTP/1 requests. For HTTP/2 requests, the analogous verification is done via
pseudo header field verification of the `:scheme`, `:authority`, and
`:path` fields using the above described field verification.

Request target verification rules are stipulated via a sequence value for the
`url` node rather than the scalar value used in `client-request` nodes. The
verifiable parts of the request target follow the URI specification (see
[RFC 3986 section 3](https://tools.ietf.org/html/rfc3986#section-3) for the formal
definition of these various terms):

* `scheme`
* `host`
* `port`
* `authority` (also known as `net-loc`, the combination of `host` and `port`),
* `path`
* `query`
* `fragment`

For example, consider the following request line:

```
    GET http://example.one:8080/path?query=q#Frag HTTP/1.1
```

The request URL in this case is case is
`http://example.one:8080/path?query=q#Frag`. The Verifier server can be
configured to verify the various parts of such URLs using the same map sytax
explained above for field verification using any of those same directives
(`equal`, `contains`, etc.). Continuing with this example URL, the following
uses the `equal` directive for each part of the URL, thus verifying that the
request URL exactly matches the URL given in this example and emitting a
verification error message if any parts of the URL do not match:

```YAML
  proxy-request:
    url:
    - [ scheme,   { value: http,        as: equal } ]
    - [ host,     { value: example.one, as: equal } ]
    - [ port,     { value: 8080,        as: equal } ]
    - [ path,     { value: /path,       as: equal } ]
    - [ query,    { value: query=q,     as: equal } ]
    - [ fragment, { value: Frag,        as: equal } ]
```

Alternatively to `host` and `port`, `authority`, with an alias of `net-loc`, is
supported, which is the combination of the two:

```YAML
  - [ authority, { value: example.one:8080, as: equal } ]
```

As another example using other directives, consider a request URL of
`/path/x/y?query=q#Frag`. Verification of this can be specified with the
following:

```YAML
  proxy-request:
    url:
    - [ scheme,    { value: http,      as: absent } ]
    - [ authority, { value: foo,       as: absent } ]
    - [ path,      { value: /path/x/y, as: equal } ]
    - [ query,     { value: query=q,   as: equal } ]
    - [ fragment,  { value: foo,       as: present } ]
```

Note that `scheme` and `authority` parts both use `absent` directives because
this particular URL just has path, query, and fragment components. Thus, with
this verification specification, if the proxy includes scheme or authority in
the request target, it will result in a verification failure. The `path` and
`query` components must match `/path/x/y` and `query=q` exactly because they
use the `equal` directive. The `fragment` of the URL is verified with the
`present` directive in this case, indicating that the received URL from the
proxy only needs to have some fragment of any value to pass this specified
verification.

### Status Verification

Proxy HTTP response status verification is specified in `proxy-response`
nodes. In this case, the response status that the Verifier client should expect
from the proxy is specified in the same way that directs the Verifier server
in what response status should be sent for a given request.

For example, the following complete `proxy-response` node directs the Proxy
Verifier client to verify that the proxy replies to the associated HTTP request
with a `404` status:

```YAML
  proxy-response:
    status: 404
```

This verification directive applies to HTTP/1 transactions. For HTTP/2, status
verification is specified via `:status` pseudo header field verification using
the field verification mechanism described above.

Verification of HTTP response reason strings, such as "Not Found", is not
currently supported.

### Example Replay File

The sections leading up to this one have described each of the major components
of a YAML Proxy Verifier replay file. Putting these components together, the
following complete sample replay file demonstrates the description of the
replay of two sessions: one an HTTP/1.1 session, the second an HTTP/2 session.
Each session contains a single transaction with verification of certain parts
of the HTTP messages.

<!---
NOTE: doctest.test.py runs with this exact replay file and should be maintained
as such to verify that this sample replay file is valid. It would be really
annoying to users, and wasteful of their time, if this file, as is, does not
run correctly.
-->

```YAML
meta:
    version: '1.0'

sessions:

#
# First session: since there is no "protocol" node for this session,
# HTTP/1.1 over TCP (no TLS) is assumed.
#
- transactions:

    #
    # Direct the Proxy Verifier client to send a POST request with a body of
    # 399 bytes.
    #
  - client-request:
      method: POST
      url: /pictures/flower.jpeg
      version: '1.1'
      headers:
        fields:
        - [ Host, www.example.com ]
        - [ Content-Type, image/jpeg ]
        - [ Content-Length, '399' ]
        - [ uuid, first-request ]
      # A "content" node is not needed if a Content-Length field is specified.

    #
    # Direct the Proxy Verifier server to verify that the request received from
    # the proxy has a path in the request target that contains "flower.jpeg"
    # and has the Content-Length field of any value.
    #
    proxy-request:
      url:
      - [ path, { value: flower.jpeg, as: contains } ]

      headers:
        fields:
        - [ Content-Length, { value: '399', as: present } ]

    #
    # Direct the Proxy Verifier server to reply with a 200 OK response with a body
    # of 3,432 bytes.
    #
    server-response:
        status: 200
        reason: OK
        headers:
          fields:
          - [ Date, "Sat, 16 Mar 2019 03:11:36 GMT" ]
          - [ Content-Type, image/jpeg ]
          - [ Transfer-Encoding, chunked ]
          - [ Connection, keep-alive ]
        # Unlike the request which contains a Content-Length, this response
        # will require a "content" node to specify the size of the body.
        # Otherwise Proxy Verifier has no way of knowing how large the response
        # should be.
        content:
          size: 3432

    #
    # Direct the Proxy Verifier client to verify that it receives a 200 OK from
    # the proxy with a `Transfer-Encoding: chunked` header field.
    #
    proxy-response:
      status: 200
      headers:
        fields:
        - [ Transfer-Encoding, { value: chunked, as: equal } ]

#
# For the second session, we use a protocol node to configure HTTP/2 using an
# SNI of # test_sni in the TLS handshake.
#
- protocol:
  - name: http
    version: 2
  - name: tls
    sni: test_sni
  - name: tcp
  - name: ip

  transactions:

  #
  # Direct the Proxy Verifier client to send a POST request with a body of
  # 399 bytes.
  #
  - client-request:
      headers:
        fields:
        - [ :method, POST ]
        - [ :scheme, https ]
        - [ :authority, www.example.com ]
        - [ :path, /pictures/flower.jpeg ]
        - [ Content-Type, image/jpeg ]
        - [ uuid, second-request ]
      content:
        size: 399

    #
    # Direct the Proxy Verifier server to verify that the request received from
    # the proxy has a path pseudo header field that contains "flower.jpeg"
    # and has a field "Content-Type: image/jpeg".
    #
    proxy-request:
      url:
      - [ path, { value: flower.jpeg, as: contains } ]

      headers:
        fields:
        - [ :method, POST ]
        - [ :scheme, https ]
        - [ :authority, www.example.com ]
        - [ :path,        { value: flower.jpeg, as: contains } ]
        - [ Content-Type, { value: image/jpeg,  as: equal } ]

    #
    # Direct the Proxy Verifier server to reply with a 200 OK response with a body
    # of 3,432 bytes.
    #
    server-response:
      headers:
        fields:
        - [ :status, 200 ]
        - [ Date, "Sat, 16 Mar 2019 03:11:36 GMT" ]
        - [ Content-Type, image/jpeg ]
      content:
        size: 3432

    #
    # Direct the Proxy Verifier client to verify that it receives a 200 OK from
    # the proxy.
    #
    proxy-response:
      status: 200
```

## Install

These instructions describe how to build a copy of the Proxy Verifier project
on your local machine for development and testing purposes.


### Prerequisites

Building and running Proxy Verifier requires the following to be installed on the system:

* SCons. Proxy Verifier is built using the [SCons](https://scons.org) Python
  build tool.
* OpenSSL. The version of OpenSSL compiled against will dictate the TLS version
  the built Proxy Verifier will support. Use at least version 1.1.1 for TLS 1.3
  support.
* [Nghttp2](https://nghttp2.org) This is the framework used for parsing HTTP/2
  traffic. Main development of Proxy Verifier has been done with version 1.39,
  but earlier versions may work as well.

### Building

OpenSSL and Nghttp2 are linked against dynamically and have their own SCons
arguments to point to their locations. SCons is a Python module. For
convenience, a Pipfile exists at the root of the Proxy Verifier repo that
specifies the SCons Python modules needed to build Proxy Verifier. Assuming you
have [pipenv](https://pypi.org/project/pipenv/) installed in your environment,
you can simply use `pipenv install` to configure your Python virtual
environment for SCons, enter that environment with `pipenv shell`, and
then build using the `scons` command.

```
pipenv install
pipenv shell
scons \
    -j8 \
    --with-ssl=/path/to/openssl \
    --with-nghttp2=/path/to/nghttp2 \
    --cfg=release \
    proxy-verifier
```

This will build `verifier-client` `verifier-server` in the `bin/` directory at
the root of the repository. Note:

1. `-j8` directs scons to build with 8 threads. Adjust according to the
   capabilities of your build system.
1. `--with-ssl` and `--with-nghttp2` both take the path to the system's opennsl
   and nghttp2 devel install locations, respectively. Proxy Verifier will be
   dynamically linked with these libraries.
1. By default scons does a debug build without optimization. `--cfg=release`
   directs it to do a non-debug build for the various components with
   optimization enabled (e.g., with `-O2` for g++ builds). This is critical if
   replaying high volumes of traffic.

### Running the Tests

#### Unit Tests

To build and run the unit tests, use the `run_utest` Scons target (this assumes
you are in the pipenv shell you used to build Proxy Verifier, see above):

```
scons \
    -j8 \
    --with-ssl=/path/to/openssl \
    --with-nghttp2=/path/to/nghttp2 \
    --cfg=release \
    run_utest::
```

#### Gold Tests
Proxy Verifier ships with a set of automated end to end tests written using the
[AuTest](https://bitbucket.org/autestsuite/reusable-gold-testing-system/src/master/)
framework. To run them, simply run the `autest.sh` script:

```
cd test/autests
./autest.sh
```

When doing development for which a particular AuTest is relevant, the `-f`
option can be used to run just a particular test (or set of tests, specified
in a space-separated list). For instance, the following invocation runs
just the http and https tests:

```
./autest.sh -f http https
```

AuTest supports a variety of other options. Run `./autest.sh --help` to get a
quick description of the various command-line options. See the [AuTest
Documentation](https://autestsuite.bitbucket.io) for further details about the
framework.

## Usage

This section describes how to run the Proxy Verifier client and server at
the command line.

### Required Arguments

At a high level, Proxy Verifier is run in the following manner:

1. Run the verifier-server with the set of HTTP and HTTPS ports to listen on
   configured though the command line. The directory containing the replay file
   is also configured through a command line argument.
1. Configure and run the proxy to listen on a set of HTTP and HTTPS ports and
   to proxy those connections to the listening verifier-server ports.
1. Run the verifier-client with the sets of HTTP and HTTPS ports on which to
   connect configured though the command line. The directory containing the
   replay file is also configured through a command line argument.

Here's an example invocation of the verifier-server, configuring it to listen on
localhost port 8080 for HTTP connections and localhost port 4443 for HTTPS
connections:

```
verifier-server \
    run \
    --listen-http 127.0.0.1:8080 \
    --listen-https 127.0.0.1:4443 \
    --server-cert <server_cert> \
    --ca-certs <file_or_directory_of_ca_certs> \
    <replay_file_or_directory>
```

Here's an example invocation of the verifier-client, configuring it to connect to
the proxy which has been  configured to listen on localhost port 8081 for HTTP
connections and localhost port 4444 for HTTPS connections:

```
verifier-client \
    run \
    --client-cert <client_cert> \
    --ca-certs <file_or_directory_of_ca_certs> \
    --connect-http 127.0.0.1:8081 \
    --connect-https 127.0.0.1:4444 \
    <replay_file_or_directory>
```

With these two invocations, the verifier-client and verifier-server will replay the
sessions and transactions in `<replay_file_or_directory>`  and perform any field
verification described therein.

On the server either `--listen-http` or `--listen-https` or both must be
provided. That is, for example, if you are only testing HTTPS traffic, you may
only specify `--listen-https`. The same is true on the client: either
`--connect-http` or `--connect-https` or both must be provided. These address
arguments take a comma-separated list of address/port pairs to specify multiple
listening or connecting sockets. The processing of these arguments
automatically detects any IPv6 addresses if provided. The client's processing
of `--connect-http` and `--connect-https` arguments will resolve fully
qualified domain names.

Note that the `--client-cert` and `--server-cert` both take either a
certificate file containing the public and private key or a directory
containing pem and key files. Similarly, the `--ca-certs` takes either a file
containing one or more certificates or a directory with separate certificate
files.  For convenience, the
[test/keys](https://github.com/bneradt/proxy-verifier/tree/expand_readme/test/keys)
directory contains key files which can be used for testing. These certificate
arguments are only required if HTTPS traffic will be replayed.

### Optional Arguments

#### --format \<format-specification\>

Each transaction has to be uniquely identifiable by the client and server in a
way that is consistent across both replay file parsing and traffic replay
processing.  Whatever attributes we use from the messages to uniquely identify
transactions is called the "key" for the dataset. The ability to uniquely
identify these messages is important for at least the following reasons:

* When the Verifier server receives a request, it has to know from which of the
  set of parsed transactions it should generate a response. At the time of
  processing an incoming message, all it has to go on is the request header
  line and the request header fields. From these, it has to be able to identify
  which of the potentially thousands of parsed transactions from the replay input
  files it should generate a response.
* When the client and server perform field verification, they need to know what
  particular verification rules specified in the replay files should be applied
  to the given incoming message.
* If the client and server are processing many transactions, generic log
  messages could be near useless if there was not a way for the logs to
  identify individual transactions to the user somehow.

By default the Verifier client and server both expect a `uuid` header field
value to function as the key.

If the user would like to use other attributes as a key, they can specify
something else via the `--format` argument. The format argument currently
supports generating a key on arbitrary field values and the `URL` of the
request. Some example `--format` expressions include:

* `--format "{field.uuid}"`: This is the default key format. It treats the UUID
  header field value as the transaction key.
* `--format "{url}"`: Treat the request `URL` as the key.
* `--format "{field.host}"`: Treat the `Host` header field value as the key.
* `--format "{field.host}/{url}"`: Treat the combination of the `Host` header
  field and the request `URL` as the key.

#### --keys \<key1 key2 ... keyn\>

`--keys` can be passed to the verifier-client to specify a subset of keys from
the replay file to run. Only the transactions from the space-separated list of
keys will be replayed. For example, the following invocation will only run the
transactions with keys whose values are 3 and 5:

```
verifier-client \
    run \
    <replay_file_diretory> \
    127.0.0.1:8082 \
    127.0.0.1:4443 \
    --keys 3 5
```

This is a client-side only option.

#### --verbose

Proxy Verifier has four levels of verbosity that it can run with:

| Verbosity | Description |
| --------- | ----------- |
| error     | Transactions either failed to run or failed verification. |
| warning   | A non-failing problem occurred but something is likely to go wrong in the future. |
| info      | High level test execution information. |
| diag      | Low level debug information. |


Each level implies the ones above it. Thus, if a user specifies a verbosity
level of `warning`, then both warning and error messages are reported.

By default, Proxy Verifier runs at `info` verbosity, only producing summary
output by both the client and the server along with any warnings and errors it
found. This can be tweaked via the `--verbose` flag. Here's an example of requesting
the most verbose level of logging (`diag`):

```
verifier-client \
    run \
    <replay_file_diretory> \
    127.0.0.1:8082 \
    127.0.0.1:4443 \
    --verbose diag
```

#### --no-proxy

As explained above, replay files contain traffic information for both client to
proxy traffic and proxy to server traffic.  Under certain circumstances it may
be helpful to run the Verifier client directly against the Verifier server.
This can be useful while developing Proxy Verifier itself, for example,
allowing the developer to do some limited testing without requiring the setup
of a test proxy.

To support this, the Verifier client has the `--no-proxy` option. If this
option is used, then the client has its expectations configured such that it
assumes it is run against the Verifier server rather than a proxy. Effectively
this means that instead of trying to run the client to proxy traffic, it will
instead act as the proxy host for the Verifier server and will run the proxy to
server traffic. Concretely, this means that the Verifier client will replay the
`proxy-request` and `proxy-response` nodes rather than the `client-request` and
`client-response` nodes.

This is a client-side only option.

#### --strict

Generally, very little about the replayed traffic is verified except what is
explicitly specified via field verification (see above). This is by design,
allowing the user to replay traffic with only the requested content being
verified. In high-volume cases, such as situations where Proxy Verifier is
being used to scale test the proxy, traffic verification may be considered
unimportant or even unnecessarily noisy. If, however, the user wants every
field to be verified regardless of specification, then the `--strict` option
can be passed to either or both the Proxy Verifier client and server to report
any verification issues against every field specified in the replay file.

#### --rate \<requests/second\>

By default, the client will replay the session and transactions in the replay
files as fast as possible. If the user desires to configure the client to
replay the transactions at a particular rate, they can provide the `--rate`
argument. This argument takes the number of requests per second the client will
attempt to send requests at.

Note session and transaction timing data can be specified in the replay files.
These are provided via `start-time` nodes for each `session` and `transaction`.
`start-time` takes as a value the number of nanoseconds since Unix epoch (or
whatever other time of reference observed by all `start-time` nodes in the set
of replay files being run) associated for that session or transaction. With
this timing information, if `--rate` is provided, Proxy Verifier simply scales
the relative time deltas between sessions and transactions that appropriately
achieves the desired transaction rate. [Traffic
Dump](https://docs.trafficserver.apache.org/en/latest/admin-guide/plugins/traffic_dump.en.html)
records such timing information when it writes replay files.  In the absence of
`start-time` nodes, Proxy Verifier will attempt to apply an appropriate uniform
delay across the sessions and transactions to achieve the specified `--rate`
value.

This is a client-side only option.

#### --repeat \<number\>

By default, the client will replay all the transactions once in the set of
input replay files. If the user would like the client to automatically repeat
this set a number of times, they can provide the `--repeat` argument. The
argument takes the number of times the client should replay the entire dataset.

This is a client-side only option.

## Contribute

Please refer to [CONTRIBUTING](CONTRIBUTING.md) for information about how to get involved. We welcome issues, questions, and pull requests.

## License

This project is licensed under the terms of the Apache 2.0 open source license.
Please refer to [LICENSE](LICENSE) for the full terms.
