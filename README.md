<!---
The following toc was autogenerated from the shell using:
https://github.com/ekalinin/github-markdown-toc

cd ~/bin
wget https://raw.githubusercontent.com/ekalinin/github-markdown-toc/master/gh-md-toc
chmod 755 gh-md-toc
cd <path/to/proxy-verifier/repo>
gh-md-toc README.md

Then copy and paste the output here.
-->

Table of Contents
=================

   * [Table of Contents](#table-of-contents)
   * [Proxy Verifier](#proxy-verifier)
      * [Traffic Replay Specification](#traffic-replay-specification)
         * [Server Response Lookup](#server-response-lookup)
      * [Traffic Verification Specification](#traffic-verification-specification)
         * [Field Verification](#field-verification)
         * [URL Verification](#url-verification)
         * [Status Verification](#status-verification)
         * [Example Replay File](#example-replay-file)
      * [Install](#install)
         * [Prerequisites](#prerequisites)
         * [Building](#building)
         * [Running the Tests](#running-the-tests)
            * [Unit Tests](#unit-tests)
            * [Gold Tests](#gold-tests)
      * [Usage](#usage)
         * [Required Arguments](#required-arguments)
         * [Optional Arguments](#optional-arguments)
            * [--format &lt;format-specification&gt;](#--format-format-specification)
            * [--keys &lt;key1 key2 ... keyn&gt;](#--keys-key1-key2--keyn)
            * [--verbose](#--verbose)
            * [--no-proxy](#--no-proxy)
            * [--strict](#--strict)
            * [--rate &lt;requests/second&gt;](#--rate-requestssecond)
            * [--repeat &lt;number&gt;](#--repeat-number)
      * [Contribute](#contribute)
      * [License](#license)

# Proxy Verifier

Proxy Verifier is an HTTP replay tool designed to verify the behavior of HTTP
proxies. It builds a verifier-client binary and a verifier-server binary which
each read a set of YAML files (or JSON files, since JSON is YAML) that specify
the HTTP traffic for the two to exchange.

Proxy Verifier supports the HTTP replay of the following protocols:

* HTTP/1.x and HTTP/2
* HTTP and HTTP over TLS
* IPv4 and IPv6

## Traffic Replay Specification

Proxy Verifier traffic behavior is specified via YAML files. The behavior for
each connection is specified under the top-most `sessions:` node, the value of
which is a sequence where each item in the sequence describes the
characteristics of each connection. For each session the protocol stack can be
specified via the `protocol:` node. This node describes the protocol
characteristics of the connection: what version of HTTP to use, whether to use
TLS and and what the characteristics of the TLS handshake should be, and
whether to use IPv4 or IPv6. In the absence of a `protocol:` node the default
protocol is HTTP/1 over IPv4.  Each session is run in parallel by the
verifier-client.

In addition to the protocol specification, each session in the `sessions:`
sequence contains a `transactions:` node. This itself is a sequence of
transactions that should be replayed for the associated session. Within each
transaction, Proxy Verifier's traffic replay behavior is specified in the
`client-request` and `server-response` nodes. `client-request` nodes are used
by the Proxy Verifier client and tell it what kind of HTTP requests it should
generate. `server-response` nodes are used by the Proxy Verifier server to
indicate what HTTP responses it should generate. Proxy traffic verification
behavior is described in the `proxy-request` and `proxy-response` nodes which
will be covered in the following section. For HTTP/1, these transactions are
run in sequence for each session; for HTTP/2, the transactions are run in
parallel.

For HTTP/1 requests, `client-request` has a map as a value which contains each of
the following key/value YAML nodes:

1. `method`: This takes the HTTP method as the value, such as `GET` or `POST`.
1. `url`: This takes the request target as the value, such as `/a/path.asp` or
   `https://www.example.com/a/path.asp`.
1. `version`: This takes the HTTP version, such as `1.1` or `2`.
1. `headers`: This takes a `fields` node which has, as a value, a sequence of
   HTTP fields. Each field is itself a sequence of two values: the name of the
   field and the value for the field.
1. Finally, the size of the request body is specified via the `content` node
   which itself takes a map as a value. This map will contain an item with
   `size` as its name which maps to an integer describing how many bytes the body
   should be.

Here's an example of a `client-request` node describing an HTTP/1.1 POST
request with a request target of `/pictures/flower.jpeg`
and containing four header fields with a body size of 399 bytes:

```YAML
  client-request:
    method: POST
    url: /pictures/flower.jpeg
    version: '1.1'
    headers:
      fields:
      - [ Host, www.example.com ]
      - [ Content-Type, application/octet-stream ]
      - [ Content-Length, '399' ]
      - [ uuid, 1234 ]
    content:
        size: 399
```

For HTTP/2, the protocol describes the initial request line values with pseudo
header fields. For that protocol, therefore, the user need not specify the
`method`, `url`, and `version` nodes and would instead specify these values
more naturally as pseudo headers in the `fields` sequence. Here is an example of
an HTTP/2 `client-request` analogous to the HTTP/1 request above (note that the
`Content-Length` header field is optional in HTTP/2 and as such is omitted here):

```YAML
  client-request:
    headers:
      fields:
      - [ :method, POST ]
      - [ :scheme, https ]
      - [ :authority, www.example.com ]
      - [ :path, /pictures/flower.jpeg ]
      - [ Content-Type, application/octet-stream ]
      - [ Content-Length, '399' ]
      - [ uuid, 1234 ]
      content:
        size: 399
```

`server-response` nodes indicate how the Proxy Verifier server should respond
to HTTP requests. In place of `method`, `url`, and `version`, HTTP/1 responses
take the following nodes:

1. `status`: This takes an integer corresponding to the HTTP response status,
   such as `200` or `404`.
1. `reason`: This takes a string that describes the status, such as `"OK"` or
   `"Not Found"`.

Here's an example of an HTTP/1 `server-response` with a status of 200, four
fields, and a body of size 3,432 bytes:

```YAML
  server-response:
    status: 200
    reason: OK
    headers:
      fields:
      - [ Date, "Sat, 16 Mar 2019 03:11:36 GMT" ]
      - [ Content-Type, application/octet-stream ]
      - [ Transfer-Encoding, chunked ]
      - [ Connection, keep-alive ]
    content:
      size: 3432
```

Observe in this case that the response contains the `Transfer-Encoding:
chunked` header field, indicating that the body should be chunk encoded. Proxy
Verifier supports chunk encoding for both requests and responses and will use
this when it detects the `Transfer-Encoding: chunked` header field. In this
case, the 3,432 bytes will be the size of the chunked body payload without the
bytes for the chunk protocol (chunk headers, etc.).

For HTTP/2, the status code is described in the `:status` pseudo header field.
Also, HTTP/2 does not allow for chunk encoding nor does it use the `Connection`
header field, using instead its framing mechanism to describe the body and
session lifetime. An analogous HTTP/2 response to the HTTP/1 request above,
therefore, would look like the following:

```YAML
  server-response:
    headers:
      fields:
      - [ :status, 200 ]
      - [ Date, "Sat, 16 Mar 2019 03:11:36 GMT" ]
      - [ Content-Type, application/octet-stream ]
    content:
      size: 3432
```

### Server Response Lookup

The `client-request` and `server-response` nodes are all that is required to
direct Proxy Verifier's replay of a transaction. The next section will describe
how to specify proxy transaction behavior via the `proxy-request` and
`proxy-response` nodes. Before proceeding to that, however, it is valuable to
understand how the Verifier server decides which response to send for any given
request it receives.  Consider again the `client-request` node in the preceding
example:

```YAML
  client-request:
    headers:
      fields:
      - [ :method, POST ]
      - [ :scheme, https ]
      - [ :authority, www.example.com ]
      - [ :path, /pictures/flower.jpeg ]
      - [ Content-Type, application/octet-stream ]
      - [ Content-Length, '399' ]
      - [ uuid, 1234 ]
      content:
        size: 399
```

Note the presence of the `uuid` field. A field such as this is sent by the
client and used by the server. When a server receives a request, keep in mind
that all it has to direct its behavior is what it has parsed from the replay
file or files and what it sees in the request. There may be hundreds of
thousands of parsed `server-response` nodes, each describing a unique response
with which the server may reply for any given incoming request. The server does
not talk directly to the client, so it cannot communicate with it and say, "Hey
Verifier client, I just read such and such request off the wire. Which response
would you like me to send for this?" When it receives an HTTP request,
therefore, it only has the contents of that request from which to choose its
response. To facilitate the server's behavior, a unique *key* is associated
with every request. During the YAML parsing phase, the Verifier server
associates each parsed `server-response` with a key it derives from the
associated `client-request` for the transaction. During the traffic replay
phase, when it reads a request off the wire, it derives a key from the HTTP
request using the same process for generating keys from `client-request` nodes
used in the parsing phase. It then looks up the proper YAML-specified response
using that key. By default, Proxy Verifier uses the `uuid` HTTP header field
values as the key, as utilized in the examples in this document, but this is
configurable via the `--format` command line argument. For details see the
section describing this argument below.


## Traffic Verification Specification

In addition to replaying HTTP traffic as described above, Proxy Verifier also
implements proxy traffic verification. For any given transaction, Proxy
Verifier can optionally verify characteristics of an HTTP request line (for
HTTP/1 requests - HTTP/2 requests do not have a request line), the response
status, and the content of HTTP fields for requests and responses.  Proxy
Verifier also supports field verification of HTTP/2 pseudo header fields.
Whereas `client-request` and `server-response` nodes direct the Verifier client
and server (respectively) on how to send traffic, `proxy-request` and
`proxy-response` nodes direct the server and client (respectively) on how to
verify the traffic it receives from the proxy. Thus:

* `client-request` nodes are used by the Verifier client to direct how it will
  generate requests it will send to the proxy.
* `server-response` nodes are used by the Verifier server to direct how it will
  generate responses to send to the proxy.
* `proxy-request` nodes are used by the Verifier server to direct how it will
  verify requests received from the proxy.
* `proxy-response` nodes are used by the Verifier client to direct how it will
  verify responses received from the proxy.

In the event that the proxy does not produce the stipulated traffic according
to a verification directive, the Proxy Verifier client or server that detects
the violation will emit a log indicating the violation and will, upon process
exit, return a non-zero status to the shell.

Traffic verification is an optional feature. Thus if Proxy Verifier is being
used simply to replay traffic and the verification features are not helpful,
then the user can simply omit the `proxy-request` and `proxy-response` nodes
and no verification will be performed.

The following sections describe how to specify traffic verification in the YAML
replay file.

### Field Verification

Recall that in `client-request` and `server-response` nodes, fields are
specified via a sequence of two items: the field name followed by the field
value. For instance, the following incomplete `client-request` node contains
the specification of a single `Content-Length` field (it is incomplete because
it does not specify the method, request target, etc., but this snippet
sufficiently demonstrates a typical description of an HTTP field):

```YAML
  client-request:
    headers:
      fields:
      - [ Content-Length, 399 ]
```

For this client request, Proxy Verifier is directed to create a `Content-Length`
HTTP field with a value of `399`.

Field verification is specified in a similar manner, but the second item in the
sequence is a map describing how the field should be verified. The map takes a
`value` item describing the characteristics of the value to verify, if
applicable, and an `as` item providing a directive describing how the field
should be verified.  Here is an example of a `proxy-request` node directing the
Verifier server to verify the characteristics of the `Content-Length` field
received from the proxy:

```YAML
  proxy-request:
    headers:
      fields:
      - [ Content-Length, { value: 399, as: equal } ]
```

Observe the following from this verification example:

* As described above, notice that the second entry in the field specification
  is a map instead of a scalar field value. The Proxy Verifier parser
  recognizes this map type as providing a verification specification.
* As with `client-request` and `server-response` field specifications, the
  first item in the list describes the field name, in this case
  "Content-Length". This indicates that this verification rule applies to the
  "Content-Length" HTTP field from the proxy.
* The directive is specified via the `as` key. In this example, `equal` is the
  directive for this particular field verification, indicating that the
  Verifier server should verify that the proxy's request for this transaction
  contains a `Content-Length` field with the exact value of `399`.

Proxy Verifier supports six field verification directives:

Directive  | Description
---------  | ------------
absent     |  The *absence* of a field with the specified field name.
present    | The *presence* of a field with the specified field name and having any or no value.
equal      |  The presence of a field with the specified field name and a value *equal* to the specified value.
contains   |  The presence of a field with the specified name with a value *containing* the specified value.
prefix     |  The presence of a field with the specified name with a value *prefixed* with the specified value.
suffix     |  The presence of a field with the specified name with a value *suffixed* with the specified value.

For all of these field verification behaviors, field names are matched case
insensitively while field values are matched case sensitively.

Thus the following field specification requests no field verification because it does not include a directive and the second item in the sequence is a scarlar:

```YAML
  - [ X-Forwarded-For, 10.10.10.2 ]
```

Such non-operative fields can also be specified using the map syntax without an
`as` item:

```YAML
  - [ X-Forwarded-For, { value: 10.10.10.2 } ]
```

Fields like this in `proxy-request` and `proxy-response` nodes are permissible
by Proxy Verifier's parser even though they have no functional impact (i.e.,
they do not direct Proxy Verifier's traffic behavior because they are not in
`client-request` nor `server-response` nodes, and they do not describe any
verification behavior). Allowing such fields affords the user the ability to
record the proxy's traffic behavior in situations where field verification is
not required or desired.  For example, the [Traffic
Dump](https://docs.trafficserver.apache.org/en/latest/admin-guide/plugins/traffic_dump.en.html)
Traffic Server plugin records HTTP traffic and uses these proxy HTTP fields to
indicate what fields were sent by the Traffic Server proxy to the client and
the server. This can be helpful for analyzing the proxy's behavior via these
replay files. Thus this proxy traffic recording function can be helpful to the
user even though Proxy Verifier treats the fields as non-operable.


The following demonstrates the `absent` directive which specifies that the HTTP field `X-Forwarded-For` _with any value_ should not have been sent by the proxy:

```YAML
  - [ X-Forwarded-For, { as: absent } ]
```

The following demonstrates the `present` directive which specifies that the HTTP field `X-Forwarded-For` _with any value_ should have been sent by the proxy:

```YAML
  - [ X-Forwarded-For, { as: present } ]
```

Notice that for both the `absent` and the `present` directives, the `value` map item is not relevant and need not be provided and, in fact, will be ignored by Proxy Verifier if it is provided.

The following demonstrates the `equal` directive which specifies that `X-Forwarded-For` should have been received from the proxy with the exact value "10.10.10.2":

```YAML
  - [ X-Forwarded-For, { value: 10.10.10.2, as: equal } ]
```

The following demonstrates the `contains` directive which specifies that `X-Forwarded-For` should have been received from the proxy containing the value "10" at any position in the field value:

```YAML
  - [ X-Forwarded-For, { value: 10, as: contains } ]
```

The following demonstrates the `prefix` directive which specifies that `X-Forwarded-For` should have been received from the proxy with a field value starting with "1":

```YAML
  - [ X-Forwarded-For, { value: 1, as: prefix } ]
```

The following demonstrates the `suffix` directive which specifies that `X-Forwarded-For` should have been received from the proxy with a field value ending with "2":

```YAML
  - [ X-Forwarded-For, { value: 2, as: suffix } ]
```

### URL Verification

In a manner similar to field verification described above, a mechanism exists
to verify the parts of URLs in the request line being received from the proxy
by the server. This mechanism is useful for verifying the request targets of
HTTP/1 requests. For HTTP/2 requests, the analogous verification is done via
pseudo header field verification of the `:scheme`, `:authority`, and
`:path` fields using the above described field verification.

Request target verification rules are stipulated via a sequence value for the
`url` node rather than the scalar value used in `client-request` nodes. The
verifiable parts of the request target follow the URI specification (see
[RFC 3986 section 3](https://tools.ietf.org/html/rfc3986#section-3) for the formal
definition of these various terms):

* `scheme`
* `host`
* `port`
* `authority` (also known as `net-loc`, the combination of `host` and `port`),
* `path`
* `query`
* `fragment`

For example, consider the following request line:

```
    GET http://example.one:8080/path?query=q#Frag HTTP/1.1
```

The request URL in this case is case is
`http://example.one:8080/path?query=q#Frag`. The Verifier server can be
configured to verify the various parts of such URLs using the same map sytax
explained above for field verification using any of those same directives
(`equal`, `contains`, etc.). Continuing with this example URL, the following
uses the `equal` directive for each part of the URL, thus verifying that the
request URL exactly matches the URL given in this example and emitting a
verification error message if any parts of the URL do not match:

```YAML
  proxy-request:
    url:
    - [ scheme,   { value: http,        as: equal } ]
    - [ host,     { value: example.one, as: equal } ]
    - [ port,     { value: 8080,        as: equal } ]
    - [ path,     { value: /path,       as: equal } ]
    - [ query,    { value: query=q,     as: equal } ]
    - [ fragment, { value: Frag,        as: equal } ]
```

Alternatively to `host` and `port`, `authority`, with an alias of `net-loc`, is
supported, which is the combination of the two:

```YAML
  - [ authority, { value: example.one:8080, as: equal } ]
```

As another example using other directives, consider a request URL of
`/path/x/y?query=q#Frag`. Verification of this can be specified with the
following:

```YAML
  proxy-request:
    url:
    - [ scheme,    { value: http,      as: absent } ]
    - [ authority, { value: foo,       as: absent } ]
    - [ path,      { value: /path/x/y, as: equal } ]
    - [ query,     { value: query=q,   as: equal } ]
    - [ fragment,  { value: foo,       as: present } ]
```

Note that `scheme` and `authority` parts both use `absent` directives because
this particular URL just has path, query, and fragment components. Thus, with
this verification specification, if the proxy includes scheme or authority in
the request target, it will result in a verification failure. The `path` and
`query` components must match `/path/x/y` and `query=q` exactly because they
use the `equal` directive. The `fragment` of the URL is verified with the
`present` directive in this case, indicating that the received URL from the
proxy only needs to have some fragment of any value to pass this specified
verification.

### Status Verification

Proxy HTTP response status verification is specified in `proxy-response`
nodes. In this case, the response status that the Verifier client should expect
from the proxy is specified in the same way that directs the Verifier server
in what response status should be sent for a given request.

For example, the following complete `proxy-response` node directs the Proxy
Verifier client to verify that the proxy replies to the associated HTTP request
with a `404` status:

```YAML
  proxy-response:
    status: 404
```

This verification directive applies to HTTP/1 transactions. For HTTP/2, status
verification is specified via `:status` pseudo header field verification using
the field verification mechanism described above.

Verification of HTTP response reason strings, such as "Not Found", is not
currently supported.

### Example Replay File

The sections leading up to this one have described each of the major components
of a YAML Proxy Verifier replay file. Putting these components together, the
following complete sample replay file demonstrates the description of the
replay of two sessions: one an HTTP/1.1 session, the second an HTTP/2 session.
Each session contains a single transaction with verification of certain parts
of the HTTP messages.

<!---
NOTE: doctest.test.py runs with this exact replay file and should be maintained
as such to verify that this sample replay file is valid. It would be really
annoying to users, and wasteful of their time, if this file, as is, does not
run correctly.
-->

```YAML
meta:
    version: '1.0'

sessions:

#
# First session: since there is no "protocol" node for this session,
# HTTP/1.1 over TCP (no TLS) is assumed.
#
- transactions:

    #
    # Direct the Proxy Verifier client to send a POST request with a body of
    # 399 bytes.
    #
  - client-request:
      method: POST
      url: /pictures/flower.jpeg
      version: '1.1'
      headers:
        fields:
        - [ Host, www.example.com ]
        - [ Content-Type, application/octet-stream ]
        - [ Content-Length, '399' ]
        - [ uuid, first-request ]
      content:
        size: 399

    #
    # Direct the Proxy Verifier server to verify that the request received from
    # the proxy has a path in the request target that contains "flower.jpeg"
    # and has the Content-Length field of any value.
    #
    proxy-request:
      url:
      - [ path, { value: flower.jpeg, as: contains } ]

      headers:
        fields:
        - [ Content-Length, { value: '399', as: present } ]

    #
    # Direct the Proxy Verifier server to reply with a 200 OK response with a body
    # of 3,432 bytes.
    #
    server-response:
        status: 200
        reason: OK
        headers:
          fields:
          - [ Date, "Sat, 16 Mar 2019 03:11:36 GMT" ]
          - [ Content-Type, application/octet-stream ]
          - [ Transfer-Encoding, chunked ]
          - [ Connection, keep-alive ]
        content:
          size: 3432

    #
    # Direct the Proxy Verifier client to verify that it receives a 200 OK from
    # the proxy with a `Transfer-Encoding: chunked` header field.
    #
    proxy-response:
      status: 200
      headers:
        fields:
        - [ Transfer-Encoding, { value: chunked, as: equal } ]

#
# For the second session, we use a protocol node to configure HTTP/2 using an
# SNI of # test_sni in the TLS handshake.
#
- protocol:
  - name: http
    version: 2
  - name: tls
    version: 1.2
    sni: test_sni
  - name: tcp
  - name: ip
    version: 4

  transactions:

  #
  # Direct the Proxy Verifier client to send a POST request with a body of
  # 399 bytes.
  #
  - client-request:
      headers:
        fields:
        - [ :method, POST ]
        - [ :scheme, https ]
        - [ :authority, www.example.com ]
        - [ :path, /pictures/flower.jpeg ]
        - [ Content-Type, application/octet-stream ]
        - [ uuid, second-request ]
      content:
        size: 399

    #
    # Direct the Proxy Verifier server to verify that the request received from
    # the proxy has a path pseudo header field that contains "flower.jpeg"
    # and has a field "Content-Type: application/octet-stream".
    #
    proxy-request:
      url:
      - [ path, { value: flower.jpeg, as: contains } ]

      headers:
        fields:
        - [ :method, POST ]
        - [ :scheme, https ]
        - [ :authority, www.example.com ]
        - [ :path,        { value: flower.jpeg,              as: contains } ]
        - [ Content-Type, { value: application/octet-stream, as: equal } ]

    #
    # Direct the Proxy Verifier server to reply with a 200 OK response with a body
    # of 3,432 bytes.
    #
    server-response:
      headers:
        fields:
        - [ :status, 200 ]
        - [ Date, "Sat, 16 Mar 2019 03:11:36 GMT" ]
        - [ Content-Type, application/octet-stream ]
      content:
        size: 3432

    #
    # Direct the Proxy Verifier client to verify that it receives a 200 OK from
    # the proxy.
    #
    proxy-response:
      status: 200
```

## Install

These instructions describe how to build a copy of the Proxy Verifier project
on your local machine for development and testing purposes.


### Prerequisites

Building and running Proxy Verifier requires the following to be installed on the system:

* SCons. Proxy Verifier is built using the [SCons](https://scons.org) Python
  build tool.
* OpenSSL. The version of OpenSSL compiled against will dictate the TLS version
  the built Proxy Verifier will support. Use at least version 1.1.1 for TLS 1.3
  support.
* [Nghttp2](https://nghttp2.org) This is the framework used for parsing HTTP/2
  traffic. Main development of Proxy Verifier has been done with version 1.39,
  but earlier versions may work as well.

### Building

OpenSSL and Nghttp2 are linked against dynamically and have their own SCons
arguments to point to their locations. SCons is a Python module. For
convenience, a Pipfile exists at the root of the Proxy Verifier repo that
specifies the SCons Python modules needed to build Proxy Verifier. Assuming you
have [pipenv](https://pypi.org/project/pipenv/) installed in your environment,
you can simply use `pipenv install` to configure your Python virtual
environment for SCons, enter that environment with `pipenv shell`, and
then build using the `scons` command.

```
pipenv install
pipenv shell
scons \
    -j8 \
    --with-ssl=/path/to/openssl \
    --with-nghttp2=/path/to/nghttp2 \
    --cfg=release \
    proxy-verifier
```

This will build `verifier-client` `verifier-server` in the `bin/` directory at
the root of the repository. Note:

1. `-j8` directs scons to build with 8 threads. Adjust according to the
   capabilities of your build system.
1. `--with-ssl` and `--with-nghttp2` both take the path to the system's opennsl
   and nghttp2 devel install locations, respectively. Proxy Verifier will be
   dynamically linked with these libraries.
1. By default scons does a debug build without optimization. `--cfg=release`
   directs it to do a non-debug build for the various components with
   optimization enabled (e.g., with `-O2` for g++ builds). This is critical if
   replaying high volumes of traffic.

### Running the Tests

#### Unit Tests

To build and run the unit tests, use the `run_utest` Scons target (this assumes
you are in the pipenv shell you used to build Proxy Verifier, see above):

```
scons \
    -j8 \
    --with-ssl=/path/to/openssl \
    --with-nghttp2=/path/to/nghttp2 \
    --cfg=release \
    run_utest::
```

#### Gold Tests
Proxy Verifier ships with a set of automated end to end tests written using the
[AuTest](https://bitbucket.org/autestsuite/reusable-gold-testing-system/src/master/)
framework. To run them, simply run the `autest.sh` script:

```
cd test/autests
./autest.sh
```

When doing development for which a particular AuTest is relevant, the `-f`
option can be used to run just a particular test (or set of tests, specified
in a space-separated list). For instance, the following invocation runs
just the http and https tests:

```
./autest.sh -f http https
```

AuTest supports a variety of other options. Run `./autest.sh --help` to get a
quick description of the various command-line options. See the [AuTest
Documentation](https://autestsuite.bitbucket.io) for further details about the
framework.

## Usage

This section describes how to run the Proxy Verifier client and server at
the command line.

### Required Arguments

At a high level, Proxy Verifier is run in the following manner:

1. Run the verifier-server with the set of HTTP and HTTPS ports to listen on
   configured though the command line. The directory containing the replay file
   is also configured through a command line argument.
1. Configure and run the proxy to listen on a set of HTTP and HTTPS ports and
   to proxy those connections to the listening verifier-server ports.
1. Run the verifier-client with the sets of HTTP and HTTPS ports on which to
   connect configured though the command line. The directory containing the
   replay file is also configured through a command line argument.

Here's an example invocation of the verifier-server, configuring it to listen on
localhost port 8080 for HTTP connections and localhost port 4443 for HTTPS
connections:

```
verifier-server \
    run \
    --listen 127.0.0.1:8080 \
    --listen-https 127.0.0.1:4443 \
    --server-cert <server_cert> \
    --ca-certs <file_or_directory_of_ca_certs> \
    <replay_file_directory>
```

Here's an example invocation of the verifier-client, configuring it to connect to
the proxy which has been  configured to listen on localhost port 8081 for HTTP
connections and localhost port 4444 for HTTPS connections:

```
verifier-client \
    run \
    --client-cert <client_cert> \
    --ca-certs <file_or_directory_of_ca_certs> \
    <replay_file_directory> \
    127.0.0.1:8081 \
    127.0.0.1:4444
```

With these two invocations, the verifier-client and verifier-server will replay the
sessions and transactions in `<replay_file_directory>`  and perform any field
verification described therein.

Note that the `--client-cert` and `--server-cert` both take either a
certificate file containing the public and private key or a directory
containing pem and key files. Similarly, the `--ca-certs` takes either a file
containing one or more certificates or a directory with separate certificate
files.  For convenience, the
[test/keys](https://github.com/bneradt/proxy-verifier/tree/expand_readme/test/keys)
directory contains key files which can be used for testing.

### Optional Arguments

#### --format \<format-specification\>

Each transaction has to be uniquely identifiable by the client and server in a
way that is consistent across both replay file parsing and traffic replay
processing.  Whatever attributes we use from the messages to uniquely identify
transactions is called the "key" for the dataset. The ability to uniquely
identify these messages is important for at least the following reasons:

* When the Verifier server receives a request, it has to know from which of the
  set of parsed transactions it should generate a response. At the time of
  processing an incoming message, all it has to go on is the request header
  line and the request header fields. From these, it has to be able to identify
  which of the potentially thousands of parsed transactions from the replay input
  files it should generate a response.
* When the client and server perform field verification, they need to know what
  particular verification rules specified in the replay files should be applied
  to the given incoming message.
* If the client and server are processing many transactions, generic log
  messages could be near useless if there was not a way for the logs to
  identify individual transactions to the user somehow.

By default the Verifier client and server both expect a `uuid` header field
value to function as the key.

If the user would like to use other attributes as a key, they can specify
something else via the `--format` argument. The format argument currently
supports generating a key on arbitrary field values and the `URL` of the
request. Some example `--format` expressions include:

* `--format "{field.uuid}"`: This is the default key format. It treats the UUID
  header field value as the transaction key.
* `--format "{url}"`: Treat the request `URL` as the key.
* `--format "{field.host}"`: Treat the `Host` header field value as the key.
* `--format "{field.host}/{url}"`: Treat the combination of the `Host` header
  field and the request `URL` as the key.

#### --keys \<key1 key2 ... keyn\>

`--keys` can be passed to the verifier-client to specify a subset of keys from
the replay file to run. Only the transactions from the space-separated list of
keys will be replayed. For example, the following invocation will only run the
transactions with keys whose values are 3 and 5:

```
verifier-client \
    run \
    <replay_file_diretory> \
    127.0.0.1:8082 \
    127.0.0.1:4443 \
    --keys 3 5
```

This is a client-side only option.

#### --verbose

Proxy Verifier has four levels of verbosity that it can run with:

| Verbosity | Description |
| --------- | ----------- |
| error     | Transactions either failed to run or failed verification. |
| warning   | A non-failing problem occurred but something is likely to go wrong in the future. |
| info      | High level test execution information. |
| diag      | Low level debug information. |


Each level implies the ones above it. Thus, if a user specifies a verbosity
level of `warning`, then both warning and error messages are reported.

By default, Proxy Verifier runs at `info` verbosity, only producing summary
output by both the client and the server along with any warnings and errors it
found. This can be tweaked via the `--verbose` flag. Here's an example of requesting
the most verbose level of logging (`diag`):

```
verifier-client \
    run \
    <replay_file_diretory> \
    127.0.0.1:8082 \
    127.0.0.1:4443 \
    --verbose diag
```

#### --no-proxy

As explained above, replay files contain traffic information for both client to
proxy traffic and proxy to server traffic.  Under certain circumstances it may
be helpful to run the Verifier client directly against the Verifier server.
This can be useful while developing Proxy Verifier itself, for example,
allowing the developer to do some limited testing without requiring the setup
of a test proxy.

To support this, the Verifier client has the `--no-proxy` option. If this
option is used, then the client has its expectations configured such that it
assumes it is run against the Verifier server rather than a proxy. Effectively
this means that instead of trying to run the client to proxy traffic, it will
instead act as the proxy host for the Verifier server and will run the proxy to
server traffic. Concretely, this means that the Verifier client will replay the
`proxy-request` and `proxy-response` nodes rather than the `client-request` and
`client-response` nodes.

This is a client-side only option.

#### --strict

Generally, very little about the replayed traffic is verified except what is
explicitly specified via field verification (see above). This is by design,
allowing the user to replay traffic with only the requested content being
verified. In high-volume cases, such as situations where Proxy Verifier is
being used to scale test the proxy, traffic verification may be considered
unimportant or even unnecessarily noisy. If, however, the user wants every
field to be verified regardless of specification, then the `--strict` option
can be passed to either or both the Proxy Verifier client and server to report
any verification issues against every field specified in the replay file.

#### --rate \<requests/second\>

By default, the client will replay the transactions in the replay file as fast
as possible. If the user desires to configure the client to replay the
transactions at a particular rate, they can provide the `--rate` argument. The
argument takes the number of requests per second the client will attempt to
send requests at.

This is a client-side only option.

#### --repeat \<number\>

By default, the client will replay all the transactions once in the set of
input replay files. If the user would like the client to automatically repeat
this set a number of times, they can provide the `--repeat` argument. The
argument takes the number of times the client should replay the entire dataset.

This is a client-side only option.

## Contribute

Please refer to [CONTRIBUTING](CONTRIBUTING.md) for information about how to get involved. We welcome issues, questions, and pull requests.

## License

This project is licensed under the terms of the Apache 2.0 open source license.
Please refer to [LICENSE](LICENSE) for the full terms.
